import os
import json
from datetime import datetime
from llama_index.llms.openai_like import OpenAILike
from dotenv import load_dotenv

load_dotenv()

class UXAnalyzer:
    def __init__(self, api_key=None):
        """Initialize the UX Analyzer with OpenRouter LLM"""
        self.api_key = api_key or os.getenv("API_KEY")
        
        # Use a free model from OpenRouter for analysis
        self.llm = OpenAILike(
            model="mistralai/devstral-2512:free",
            api_base="https://openrouter.ai/api/v1",
            api_key=self.api_key,
            temperature=0.3
        )
    
    def read_report(self, report_path="agent_result.txt"):
        """Read the generated UX exploration report"""
        try:
            if not os.path.exists(report_path):
                print(f"Report file not found: {report_path}")
                return None
            
            with open(report_path, "r", encoding="utf-8") as f:
                content = f.read()
            
            print(f"‚úì Report loaded from {report_path}")
            return content
        except Exception as e:
            print(f"Error reading report: {str(e)}")
            return None
    
    def analyze_ux(self, report_content):
        """Send report to LLM for UX analysis"""
        analysis_prompt = f"""You are a senior UI/UX architect and product systems analyst.

You are given a UI exploration report generated by an autonomous agent.
The report represents the structural navigation graph of an application, not user behavior data.

Analyze the report with a focus on structural attention design and usability.

Your analysis MUST be based only on:
- screen hierarchy (depth)
- navigation paths
- distribution of features
- separation between consumption-oriented and utility-oriented screens

Do NOT speculate about user psychology beyond what the structure implies.
Do NOT reference real user metrics or engagement data.

---

Perform the following analyses:

1. Structural Attention Patterns
- Identify screens that act as attention hubs (many outgoing paths, shallow depth).
- Detect infinite or non-terminal navigation flows.
- Identify asymmetry between engagement screens and control/utility screens.

2. UI / UX Friction Points
- Identify screens or flows that increase cognitive load.
- Detect overloaded hubs or excessive branching.
- Identify unnecessarily deep paths to important controls or settings.

3. Feature Discoverability Issues
- Identify key features that are buried deeper than engagement features.
- Flag features that require indirect or non-obvious navigation paths.
- Highlight inconsistencies in feature access depth.

4. Navigation Complexity Assessment
- Evaluate overall navigation depth and breadth.
- Identify redundant transitions or unnecessary screen hops.
- Assess whether navigation favors exploration over task completion.

5. Improvement Recommendations
- Suggest structural changes to reduce unnecessary attention capture.
- Propose ways to surface control and utility features earlier.
- Recommend simplifications to navigation without removing functionality.

---

Return output STRICTLY in the following JSON format:

{{
  "summary": "Concise, high-level overview of structural findings and overall risk level",

  "issues": [
    {{
      "category": "Attention Hub | Navigation Depth | Discoverability | Cognitive Load | Flow Redundancy",
      "severity": "Low | Medium | High",
      "description": "Clear explanation grounded in navigation structure"
    }}
  ],

  "suggestions": [
    {{
      "priority": "Low | Medium | High",
      "recommendation": "Concrete structural or navigation change",
      "impact": "Expected effect on usability, clarity, or reduced time-waste"
    }}
  ],

  "metrics": {{
    "total_screens": <number>,
    "max_depth": <number>,
    "avg_depth": <number>,
    "hub_screen_count": <number>,
    "shallow_engagement_ratio": <number between 0 and 1>,
    "complexity_score": <number between 1 and 10>
  }}
}}

IMPORTANT:
- Output JSON only.
- No markdown.
- No explanations outside JSON.
- All claims must be structurally justified.

---

Report:
---
{report_content}
---
"""

        try:
            print("üîÑ Analyzing UX with LLM...")
            response = self.llm.complete(analysis_prompt)
            analysis_text = response.text.strip()
            
            # Remove markdown code blocks if present
            if analysis_text.startswith("```json"):
                analysis_text = analysis_text.split("```json")[1].split("```")[0].strip()
            elif analysis_text.startswith("```"):
                analysis_text = analysis_text.split("```")[1].split("```")[0].strip()
            
            analysis_json = json.loads(analysis_text)
            print("‚úì UX analysis completed")
            return analysis_json
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON response: {str(e)}")
            print(f"Raw response: {analysis_text[:500]}")
            return None
        except Exception as e:
            print(f"Error during analysis: {str(e)}")
            return None
    
    def generate_html_report(self, analysis_data):
        """Generate HTML report request via LLM"""
        html_generation_prompt = f"""You are an expert web developer. Generate a complete, professional HTML file for a UX Analysis Report.

Use the following analysis data:
{json.dumps(analysis_data, indent=2)}

Requirements:
1. Create a complete HTML5 document with proper DOCTYPE and structure
2. Include Chart.js via CDN for visualizations (pie chart for issue severity distribution, bar chart for metrics)
3. Include marked.js via CDN for markdown rendering if needed
4. Use modern, clean CSS (embedded in <style> tags)
5. Create sections for: Summary, Issues (with visual severity indicators), Suggestions (prioritized), Metrics (with charts)
6. Make it responsive and professional
7. Use a color scheme: primary #4F46E5, success #10B981, warning #F59E0B, danger #EF4444
8. Add timestamp: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

Output ONLY the complete HTML code, no explanations or markdown formatting."""

        try:
            print("üîÑ Generating HTML report with LLM...")
            response = self.llm.complete(html_generation_prompt)
            html_content = response.text.strip()
            
            # Remove markdown code blocks if present
            if html_content.startswith("```html"):
                html_content = html_content.split("```html")[1].split("```")[0].strip()
            elif html_content.startswith("```"):
                html_content = html_content.split("```")[1].split("```")[0].strip()
            
            print("‚úì HTML report generated")
            return html_content
        except Exception as e:
            print(f"Error generating HTML: {str(e)}")
            return None
    
    def save_html(self, html_content, output_path="ux_analysis_report.html"):
        """Save HTML report to file"""
        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(html_content)
            print(f"‚úì HTML report saved to {output_path}")
            return True
        except Exception as e:
            print(f"Error saving HTML: {str(e)}")
            return False
    
    def run_analysis(self, report_path="agent_result.txt", output_path="ux_analysis_report.html"):
        """Complete analysis pipeline"""
        print("\n" + "="*60)
        print("UX ANALYSIS PIPELINE")
        print("="*60 + "\n")
        
        # Step 1: Read report
        report_content = self.read_report(report_path)
        if not report_content:
            print("‚ùå Analysis aborted: No report content")
            return False
        
        # Step 2: Analyze UX
        analysis_data = self.analyze_ux(report_content)
        if not analysis_data:
            print("‚ùå Analysis aborted: Failed to analyze UX")
            return False
        
        # Save analysis JSON
        try:
            with open("ux_analysis.json", "w", encoding="utf-8") as f:
                json.dump(analysis_data, f, indent=2)
            print("‚úì Analysis JSON saved to ux_analysis.json")
        except Exception as e:
            print(f"Warning: Could not save analysis JSON: {str(e)}")
        
        # Step 3: Generate HTML
        html_content = self.generate_html_report(analysis_data)
        if not html_content:
            print("‚ùå Analysis aborted: Failed to generate HTML")
            return False
        
        # Step 4: Save HTML
        success = self.save_html(html_content, output_path)
        
        if success:
            print("\n" + "="*60)
            print(f"‚úÖ ANALYSIS COMPLETE")
            print(f"üìä View report: {output_path}")
            print("="*60 + "\n")
        
        return success


if __name__ == "__main__":
    # Run as standalone script
    analyzer = UXAnalyzer()
    analyzer.run_analysis()
